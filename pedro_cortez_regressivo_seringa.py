# -*- coding: utf-8 -*-
"""Pedro Cortez - Regressivo Seringa.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KHb07Aycpwj9g1D58_ax9tVjDjxsHqdr

# Dataset

## Baixando imagens do Google Drive
"""

import gdown

# https://drive.google.com/file/d/1qWtEN-w19UUtfWChQkxzHSOyBLENXIQa/
syrDS = 'https://drive.google.com/uc?id=1qWtEN-w19UUtfWChQkxzHSOyBLENXIQa'
gdown.download(syrDS, 'SyringeDataset.zip', quiet=False)

!unzip -qq SyringeDataset.zip -d fullds
!rm SyringeDataset.zip

"""Convertendo pastas com "ml" para apenas números (apenas para assegurar ordem das pastas)"""

# para permitir de transforma classes em valores
import os
for i in range(21):
  os.rename(f'fullds/{i:02}ml', f'fullds/{i:02}')

"""## Importando Imagens das Pastas para o TensorFlow

É usando apenas 1 dataset aqui, onde as classes são inteiras (0 a 20) conforme nome das pastas
"""

import tensorflow as tf
import numpy as np
from tensorflow.keras import datasets, layers, models
import matplotlib.pyplot as plt

directory = '/content/fullds'

# https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/image_dataset_from_directory
image_size = (128, 128)
batch_size = 32
cores = ['rgb', 'grayscale'][1]

train_ds = tf.keras.preprocessing.image_dataset_from_directory(
    directory=directory, 
    labels='inferred', 
    label_mode='int',
    class_names=None, 
    color_mode=cores, 
    batch_size=batch_size, 
    image_size=image_size, 
    shuffle=True, 
    seed=42, 
    validation_split=None, 
    subset=None,
    interpolation='bilinear', 
    follow_links=False,
    crop_to_aspect_ratio=False,
)

"""Extraindo imagens para X e tutores (targets) para y

Os tutores são convertidos de inteiros (0 a 20) para reais (float) (0.0 a 20.0)

O batch é removido, os conjunto X e y são completos sem blocos.
"""

X = np.concatenate([x for x,y in train_ds],axis=0)
y = np.concatenate([y for x,y in train_ds],axis=0)
y = y.astype(float)
X.shape, y.shape

"""# Rede Neural Convolucional Regressiva

A CNN regressiva apresenta apenas 1 saída do tipo float (real)
"""

channels = 3 if cores == 'rgb' else 1

model = models.Sequential()
model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(image_size[0], image_size[1], channels)))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.Flatten())
model.add(layers.Dense(64, activation='relu'))
model.add(layers.Dense(1)) #regressao

model.summary()

tf.keras.utils.plot_model(
    model,
    to_file="model.png",
    show_shapes=True,
    show_dtype=False,
    show_layer_names=True,
    rankdir="TB",
    expand_nested=False,
    dpi=96,
    layer_range=None,
)

model.compile(
    optimizer=tf.keras.optimizers.RMSprop(0.001),
    #optimizer = 'Adam',
    loss='mse',
    metrics=['mae', 'mse'],
    )

model.predict(X)

"""## Treinamento

Treinamento regressivo são utilizados MSE e MAE como critérios de avaliação.

RMSprop faz a otimização da rede regressiva
"""

tf.random.set_seed(42)

history = model.fit(X, y, 
                    epochs=200, 
                    validation_split=0.2,
                    verbose=2)

import matplotlib.pyplot as plt
plt.rcParams["figure.figsize"] = (10,6)
k = 5
plt.plot(history.history['loss'][k:])
plt.plot(history.history['mae'][k:])
plt.plot(history.history['val_mae'][k:])
plt.plot(history.history['val_mse'][k:])
plt.title('Treinamento')
plt.ylabel('metrica')
plt.xlabel('epoch')
plt.legend(['loss', 'mae','val_mae','val_mse'], loc='upper left')

import pandas as pd
pd.DataFrame(history.history).describe()

"""# Testes dos Resultados"""

y_pred = model.predict(X)
y_pred = [u[0] for u in y_pred]
resultados = pd.DataFrame([y, y_pred], index=['Tutor','Previsto']).T
resultados.to_csv('Resultados.csv')
resultados

resultados['Previsto'] = resultados['Previsto'].astype(int)

from sklearn.metrics import confusion_matrix
y_true = resultados['Tutor'].values
y_pred = resultados['Previsto'].values

mc = confusion_matrix(y_true, y_pred)
mc

import seaborn as sn
dfmc = pd.DataFrame(data = confusion_matrix(y_true, y_pred))
dfmc.to_latex('MatrizConfu.tex')
sn.heatmap(dfmc, annot=True, cmap="YlGnBu")

model.save('seringa_regre.h5')